---
title: "What makes a popular Reddit post?"
author: "InterstellR"
date: "May 2, 2018"
bibliography: bibliography.bib
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(digits = 2)
set.seed(20180505)
```

```{r load-packages, echo=FALSE, message=FALSE}
library(chunked)
library(infer)
library(lubridate)
library(tidytext)
library(tidyverse)
library(scales)
```

```{r load-data, echo=FALSE, message=FALSE}
# This may take a while
posts <- read_csv("../data/reddit.csv")
```

## Introduction

"Reddit is an American social news aggregation, web content rating, and discussion website" (from [Wikipedia](https://en.wikipedia.org/wiki/Reddit)). People who are members of Reddit upload their posts and other people vote and comment on said posts, the posts with the most likes appear more towards the top. They are divided by thematic categories called subreddits, as well as overall categories of top posts, new posts, controversial posts, among others.

TODO: Expand introduction

### Data Set

The data set is comprised of Reddit posts from December 2017, since it was the latest data set we could find and wanted to keep up with the most recent trends. Also,  it will be interesting to explore themes related to Christmas. We retrieved it from the Google BigQuery API. The data set contains `r ncol(posts)` variables and `r nrow(posts)` observations. 

Our dataset is made up of `r ncol(posts)` variables but for this project, we will only be looking at these variables: `subreddit` (categorical, name of the subreddit the post belongs to), `num_comments` (numerical, the number of comments on the post),`score` (numerical, popularity score of post), `ups` (numerical, amount of up votes the post recieved), `downs` (numerical, amount of down votes the post recieved), `title` (categorical, the title of the post), `selftext` (categorical, the text body on the post), `gilded` (numerical, amount of gold reddit donations from other users), `over_18` ( categorical, true or fale if post is only appropriate for users over the age of 18). The rest of the descriptions for the other variables can be found in our data folder. 

### Research Question

Coincidentally, our team is made up of avid Reddit fans. All three of us are constantly checking it for interesting, insightful, and funny posts. Given that Reddit recieves thousands of posts per day and the little time in the day we have to check Reddit, we all usually only check the "popular" feed. So, it got us thinking that we should learn more about the site we use pretty frequently. Specifically, we want to analyze what makes a Reddit post popular.

## Cleaning

The dataset we acquired is mostly clean; however, there is one thing we need to clean up before we began our analysis. The variable `created_utc` gives the date that the post was created as the difference in milliseconds from January 1st, 1970. This quantity is not very easy to read or interpret, so we convert it to a combination of day, hour, and minute. We do not need to store the month and year since these values are the same for all entries in the dataset.

```{r clean}
posts <- mutate(
  posts,
  created_date = as.POSIXct(created_utc, origin = "1970-01-01") + 5 * 60 * 60,
  created_day = day(created_date),
  created_hour = hour(created_date),
  created_minute = minute(created_date)
)
```

To check whether our conversion is correct, we can look at the range of the new date variable. We see that the first post in the dataset was on `r min(posts$created_date)` and the latest one was on `r max(posts$created_date)`. Since this range is exactly the month of December 2017, we can be confident that the conversion was successful.

## Exploring Popular Subreddits

As stricty popular-feed Reddit users, we do not know much about the various subreddits yet. Hence, we want to start by finding out what the most popular ones are and gain insights into what the posts in each one are about. As a measure of a subreddit's popularity, we decide to use the cumulative score of all of its posts. The plot below shows the nine subreddits with the highest resulting totals.

```{r active-subreddits}
popular_subs <- posts %>%
  group_by(subreddit) %>%
  summarize(
    num_posts = n(),
    total_score = sum(score)
  ) %>%
  arrange(desc(total_score)) %>%
  head(9)
ggplot(popular_subs, aes(x = reorder(subreddit, total_score), y = total_score / 1e6)) +
  geom_col() +
  labs(
    title = "Most popular subreddits",
    subtitle = "in December 2017",
    x = "",
    y = "Cumulative score of posts"
  ) +
  scale_y_continuous(
    label = unit_format("M"),
    expand = c(0, 0)
  ) +
  coord_flip() +
  theme_minimal()
```

We find that the nine most popular subreddits in descending order are `The_Donald`, `aww`, `politics`, `pics`, `gaming`, `funny`, `gifs`, `todayilearned`, and `dankmemes`. We may be able to intuit what most of these subreddits are about from their name alone, but we wanted to know more about the content and central topics in each of them. Therefore, we decided to analyze the most frequent terms in each of these subreddits with the help of the `tidytext` package. We want to focus on the text contained in the title of the posts since it is the first thing that is visible to the users. Furthermore, we decided to filter out stop words such as "the" and "a" because they naturally appear very frequently and do not convey much about the content of any one particular subreddit.

```{r tf-analysis}
# count most frequent words for each subreddit
tidy_titles <- posts %>%
  filter(subreddit %in% popular_subs$subreddit) %>%
  unnest_tokens(word, title) %>%
  anti_join(stop_words, by = "word") %>%
  count(subreddit, word, sort = TRUE) %>%
  group_by(subreddit) %>%
  top_n(10, wt = n) %>%
  ungroup() %>%
  arrange(subreddit, n) %>%
  mutate(order = row_number())
# reorder subreddit variable by popularity
tidy_titles <- tidy_titles %>%
  left_join(popular_subs, by = "subreddit") %>%
  mutate(subreddit = reorder(subreddit, desc(total_score)))
# plot results
ggplot(tidy_titles, aes(x = order, y = n, fill = subreddit)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~subreddit, scales = "free") +
  labs(
    title = "Most frequent words within various subreddits",
    subtitle = "in December 2017",
    x = "",
    y = "Count"
  ) +
  scale_x_continuous(
    breaks = tidy_titles$order,
    labels = tidy_titles$word,
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    expand = c(0, 0)
  ) +
  coord_flip() +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank())
```

TODO: Discuss results for this visualization

## Sentiment Analysis

One of the major questions we want to explore is whether positive or negative posts are more popular. Our hypothesis is that negative posts are generally more popular, as psychologists claim that humans have an innate "negativity bias" which draws them toward bad news moreso than good ones [@ito]. To test this belief, we need a way to determine the sentiment polarity of each post, i.e. how positive or negative it is. We will use the `afinn` sentiment lexicon, which provides a list of 2476 words, each associated with a score between -3 and +3. Negative words are given a negative score, and positive words are given a positive score. The higher in magnitude the score is, the more extreme the negativity or positivity of the word. For example, the word "death" has a score of -3 whereas the word "love" has a score of +3. In order to determine the overall sentiment of a post, we will simply add up the sentiments of the words contained in it.

```{r sentiment-scores}
sents <- get_sentiments("afinn")
posts <- posts %>%
  unnest_tokens(word, title) %>%
  left_join(sents, by = "word", suffix = c("", "_sent")) %>%
  filter(!is.na(score_sent)) %>%
  group_by(id) %>%
  summarize(sentiment = sum(score_sent)) %>%
  left_join(posts, ., by = "id") %>%
  mutate(sentiment = case_when(
    is.na(sentiment) ~ 0,
    TRUE             ~ as.double(sentiment)
  ))
# Find most positive title
most_pos_post <- posts %>%
  arrange(desc(sentiment)) %>%
  head(1) %>%
  pull(title)
# Find most negative title
most_neg_post <- posts %>%
  arrange(sentiment) %>%
  head(1) %>%
  pull(title)
```

We find that the average sentiment score of the posts is `r mean(posts$sentiment)` with a large standard deviation of `r sd(posts$sentiment)`. Interestingly, the title with the most positive sentiment is "`r most_pos_post`," which is a result of the word "ha" having a sentiment score of 2. We will not show the most negative post here because it contains a lot of profanity. Next, let's add an indicator variable `sent_class` to the dataframe that is "pos" if the sentiment score is positive, "neg" if the sentiment score is negative, and "neutral" if it is 0.

```{r sent-class}
posts <- mutate(posts, sent_class = case_when(
  sentiment > 0 ~ "pos",
  sentiment < 0 ~ "neg",
  sentiment == 0 ~ "neutral"
))
num_pos <- filter(posts, sent_class == "pos") %>% nrow()
num_neg <- filter(posts, sent_class == "neg") %>% nrow()
num_neutral <- filter(posts, sent_class == "neutral") %>% nrow()
```

It turns out that there are a total of `r num_pos` positive posts, `r num_neg` negative posts, and `r num_neutral` neutral posts in the dataset, provided that our method of determining sentiment is accurate. Let us examine a few posts from the positive and negative category to see whether the results make sense.

```{r pos-neg-examples}
# Look at positive posts
posts %>%
  filter(sent_class == "pos") %>%
  select(title, sent_class) %>%
  head(3)
# Look at negative posts
posts %>%
  filter(sent_class == "neg") %>%
  select(title, sent_class) %>%
  head(3)
```

It appears that the sentiment analysis results match our intuition -- the positively classified titles talk about "best drafts ever" and "obvious benefits," and the negatively classified titles talk about a technical problem with some video game and fears.

Now, we can finally test our hypothesis. The null hypothesis and the alternative hypothesis are as follows.  

H0: A post's score is independent of the title's sentiment polarity.  
HA: Negative posts have a higher mean score than positive posts.  

For this analysis, we will ignore posts with neutral sentiment and only focus on those with positive or negative sentiment polarity. Before we start, we need to verify whether all conditions for valid simulation based inference are met. Our "population" is the set of all Reddit posts in December 2017 and has a size of 10,567,492. Our sample is taken at random without replacement and has a size of 1,000,000. Since the sample size is less than 10% of the population size, the independence condition is therefore met. Additionally, we require more than 30 samples, which we also have.

First, we calculate the observed difference in mean score between posts with negative and positive `sent_class`.

```{r diff-mean-score}
mean_score_pos <- posts %>%
  filter(sent_class == "pos") %>%
  summarize(mean_score = mean(score)) %>%
  pull(mean_score)
mean_score_neg <- posts %>%
  filter(sent_class == "neg") %>%
  summarize(mean_score = mean(score)) %>%
  pull(mean_score)
diff_mean_score <- mean_score_neg - mean_score_pos
```

We find that, in our sample, negative posts have an average score which is `r diff_mean_score` higher than positive posts. Next, let's figure out whether this difference could be due to chance using bootstrapping with permutation.

```{r null-dist}
null_dist <- posts %>%
  filter(sent_class %in% c("pos", "neg")) %>%
  specify(score ~ sent_class) %>%
  hypothesize(null = "independence") %>% 
  generate(reps = 1000, type = "permute") %>% 
  calculate(stat = "diff in means", order = c("neg", "pos"))
```

The resulting null distribution of the differences in means in shown below.

```{r plot-null-dist}
ggplot(null_dist, aes(x = stat)) +
  geom_density() +
  labs(
    title = "Null distribution of difference in mean scores",
    subtitle = "between posts with negative and positive sentiments",
    x = "Score difference",
    y = "Density"
  ) +
  geom_vline(xintercept = diff_mean_score, color = "blue") +
  theme_minimal()
```

```{r calc-p2}
p_value <- null_dist %>%
  filter(stat >= diff_mean_score) %>%
  summarize(p = n() / nrow(null_dist)) %>%
  pull(p)
```

Using a one-sided hypothesis test, we find a p-value of `r p_value`. Using a significance level of 5%, we can infer that since our p-value is less than the significance level, we can reject the null hypothesis and conclude that *negative posts do indeed have a higher average mean score than positive posts*.

## Cats vs. Dogs

A hotly debated question is whether dogs or cats are more popular. We aim to once and for all determine which one is the better animal, using a hypothesis test. Our hypothesis is that the mean score of a post depends on whether the post mentions dogs or cats. We only look at posts which mention either of the two, but not both. First, we need to create two new variables called `dog` and `cat` in order to determine whether a title contains the word "cat" or "dog", repectively.

```{r find-dogs-cats}
posts <- mutate(
  posts,
  dog = case_when(
    str_detect(title, " dog ") | str_detect(title, "puppy") |
      str_detect(title, "Dog ") | str_detect(title, "Puppy ") |
      str_detect(title, "PUPPY ") | str_detect(title, " DOG ") |
      str_detect(title, " PUPPY ") ~ "yes",
    TRUE ~ "no"
  ),
  cat = case_when(
    str_detect(title, " cat ") | str_detect(title, "Cat ") |
      str_detect(title, " CAT ") | str_detect(title, "Kitten ") |
      str_detect(title, " kitten ") | str_detect(title, " KITTEN ") |
      str_detect(title, "Feline") | str_detect(title, " feline ") |
      str_detect(title, " FELINE ") ~ "yes",
    TRUE ~ "no"
  ),
  animal = case_when(
    dog == "yes" & cat == "no" ~ "dog",
    cat == "yes" & dog == "no" ~ "cat"
  )
)
# Calculate percentage of dogs and cats
perc_dogs <- posts %>%
  filter(dog == "yes") %>%
  summarize(perc_dogs = n() / nrow(posts) * 100) %>%
  pull(perc_dogs)
perc_cats <- posts %>%
  filter(cat == "yes") %>%
  summarize(perc_cats = n() / nrow(posts) * 100) %>%
  pull(perc_cats)
```

We observe that `r perc_dogs`% of the posts mention dogs and `r perc_cats`% of the posts mention cats.

Next, we are going to conduct a hypothesis test to determine whether score of a post is independent of whether its title contains "cat" or "dog". We will follow a similar procedure as for the previous test. The null hypothesis and the alternative hypothesis are as follows.  

H0: A post's score is independent of whether dogs or cats are mentioned in the title.  
HA: Dog posts have a higher mean score than cat posts.  

For the same reasons mentioned in the previous test, we can safely conduct simlation based inference here as well. First, we calculate the observed difference in mean score between posts with negative and positive `sent_class`.

```{r diff-mean-score2}
mean_score_dog <- posts %>%
  filter(animal == "dog") %>%
  summarize(mean_score = mean(score)) %>%
  pull(mean_score)
mean_score_cat <- posts %>%
  filter(animal == "cat") %>%
  summarize(mean_score = mean(score)) %>%
  pull(mean_score)
diff_mean_score2 <- mean_score_dog - mean_score_cat
```

We find that, in our sample, posts that mention dogs have an average score which is `r diff_mean_score2` higher than those that mention cats. Next, let's figure out whether this difference could be due to chance using bootstrapping with permutation.

```{r null-dist2}
null_dist2 <- posts %>%
  filter(animal %in% c("dog", "cat")) %>%
  specify(score ~ animal) %>%
  hypothesize(null = "independence") %>% 
  generate(reps = 1000, type = "permute") %>% 
  calculate(stat = "diff in means", order = c("dog", "cat"))
```

The resulting null distribution of the differences in means in shown below.

```{r plot-null-dist2}
ggplot(null_dist, aes(x = stat)) +
  geom_density() +
  labs(
    title = "Null distribution of difference in mean scores",
    subtitle = "between dog posts and cat posts",
    x = "Score difference",
    y = "Density"
  ) +
  geom_vline(xintercept = diff_mean_score2, color = "blue") +
  theme_minimal()
```

```{r calc-p}
p_value2 <- null_dist2 %>%
  filter(stat >= diff_mean_score2) %>%
  summarize(p = n() / nrow(null_dist2)) %>%
  pull(p)
```

We can clearly see that we have a p-value of `r p_value2`. This means that we can reject the null hypothesis and conclude that *dog posts indeed have a higher mean score than cat posts*.

## Modeling Popularity


```{r timeup-variable}
posts <- posts %>%
  mutate(timeup = (created_utc - retrieved_on)/3,600,000)
```

Our main resarch goal is to find out what makes a post popular. Hence, we want to build a model that can predict the score of a given post from several of its attributes. Before doing so, we visualize and summarize the distribution of the posts' scores. We will also exclude scores higher than the 90th percentile in the visualization because these posts are scores far greater than most others, making it difficult to visualize the distribution.

```{r score-dist}
score_q90 <- quantile(posts$score, probs = 0.90)
posts %>%
  filter(score < score_q90) %>%
  ggplot(aes(x = score)) +
  geom_histogram(
    bins = 40,
    color = "black",
    fill = "white"
  ) +
  labs(
    title = "Distribution of post scores",
    subtitle = "on Reddit in December 2017",
    x = "Score",
    y = "Count"
  ) +
  scale_y_continuous(label = comma) +
  theme_minimal()
```

Note that since we exclude posts above the 90th percentile, we could expect this distribution to continue with a similar trend further towards the right.

```{r clean-posts}
clean_posts <- filter(
  posts,
  !is.na(gilded),
  !is.na(stickied),
  !is.na(num_comments),
  !is.na(sent_score),
  hide_score == "false"
)
```

```{r lm-popularity}
full_model <- lm(score ~ gilded + num_comments + stickied +timeup + sent_class, data = clean_posts)

selected_model <- step(full_model, scope = . ~ .^2, direction = "backward")
```

```{r tidy-lm}
tidy(selected_model) %>% select(term, estimate)
```

Looking at the slope coeffiecents for our selected model's variables of `gilded`, `num_comments`, `stickied`, and `sent_class`, we can analyze the following. For every one gilded point a Reddit post receives, the score goes up by 4,622.4, given that all other variables remain constant. This makes sense since user really must like a post if they're willing to pay a gold donation to the creator. For every one comment the Reddit post recieves, the score goes by 3.9, given that all other variables remain constant. For when a post gets stickied by the moderators of the subreddits, the score goes down by 144.3, given that all other variables remain constant. This is an interesting analysis because we would expect a post that gets attention from the moderators and gets placed at the top of the feed would recieve a higher score but apparently that is not the case. Lastly, when a post's title is of neutral sentiment, the post's score goes down by 6.7 and if the post's title is of positive sentiment, the post's score goes down by 8.0. 


```{r getting-r2}
(selectedmodel_r2 <- glance(selected_model) %>%
  pull(adj.r.squared))
```

<<<<<<< HEAD
The r-squared for our selected_model is not very good in terms for statistical analysis. However, we expected this given that we did not look at the text of the posts when modeling the popularity score. We expect the text of the post to have a large affect on a post's popularity score. 


=======
>>>>>>> 426ba7f8ed9f2de1a5b877f14d0bbc48007cad29
## Discussion

TODO: Discuss results

## Conclusion

## References
